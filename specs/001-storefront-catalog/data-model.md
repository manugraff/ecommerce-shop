# Data Model: Storefront Catalog and Cart

**Feature**: 001-storefront-catalog  
**Date**: 2025-11-22  
**Purpose**: Define all Data Transfer Objects (DTOs) and their relationships

---

## Entity Overview

This feature uses **3 backend entities** (read-only from API) and **2 client-only entities** (cart state):

| Entity | Source | Purpose |
|--------|--------|---------|
| `ProductDTO` | Backend (PostgreSQL) | Represents a cosmetic product available for purchase |
| `CategoryDTO` | Backend (PostgreSQL) | Represents a product classification/category |
| `BrandDTO` | Backend (PostgreSQL) | Represents a product manufacturer/brand |
| `CartItemDTO` | Client (localStorage) | Represents a product in the shopping cart with quantity |
| `CartStateDTO` | Client (React Context) | Aggregates cart items with calculated totals |

---

## Backend Entities (Read-Only)

### ProductDTO

Matches backend `Product` entity exactly. Primary entity for catalog browsing.

```typescript
// src/cases/catalog/dtos/product.dto.ts

export interface ProductDTO {
  /**
   * Unique identifier (UUID)
   * Generated by backend, immutable
   */
  id: string;
  
  /**
   * Product name
   * Required, max 255 characters
   * Example: "Hydrating Face Serum"
   */
  name: string;
  
  /**
   * Full product description
   * Optional, TEXT type (no length limit)
   * Example: "A lightweight serum that provides deep hydration for all skin types."
   */
  description?: string;
  
  /**
   * Product price in Brazilian Real (BRL)
   * Required, decimal (10,2)
   * Example: 89.90
   */
  price: number;
  
  /**
   * Whether product is active and available for purchase
   * Required, default: true
   * Inactive products not shown in storefront
   */
  active: boolean;
  
  /**
   * Product category (required relationship)
   * Eager loaded from backend
   * Example: { id: "cat-123", name: "Skincare" }
   */
  category: CategoryDTO;
  
  /**
   * Product brand (optional relationship)
   * Eager loaded from backend
   * Example: { id: "brand-456", name: "Glow Up Beauty" }
   */
  brand?: BrandDTO;
}
```

**Validation Rules**:
- `id`: Must be valid UUID
- `name`: Required, non-empty, max 255 chars
- `description`: Optional, can be empty or null
- `price`: Required, positive number, max 2 decimal places
- `active`: Boolean, required
- `category`: Required, must be valid CategoryDTO
- `brand`: Optional, if present must be valid BrandDTO

**Relationships**:
- **Many-to-One** with Category (required)
- **Many-to-One** with Brand (optional)

---

### CategoryDTO

Matches backend `Category` entity exactly. Used for product filtering.

```typescript
// src/cases/catalog/dtos/category.dto.ts

export interface CategoryDTO {
  /**
   * Unique identifier (UUID)
   * Generated by backend, immutable
   */
  id: string;
  
  /**
   * Category name
   * Required, max 60 characters
   * Example: "Skincare", "Makeup", "Haircare"
   */
  name: string;
}
```

**Validation Rules**:
- `id`: Must be valid UUID
- `name`: Required, non-empty, max 60 chars

**Relationships**:
- **One-to-Many** with Product

---

### BrandDTO

Matches backend `Brand` entity exactly. Optional product metadata.

```typescript
// src/cases/catalog/dtos/brand.dto.ts

export interface BrandDTO {
  /**
   * Unique identifier (UUID)
   * Generated by backend, immutable
   */
  id: string;
  
  /**
   * Brand name
   * Required, max 60 characters
   * Example: "Glow Up Beauty", "Natural Radiance"
   */
  name: string;
}
```

**Validation Rules**:
- `id`: Must be valid UUID
- `name`: Required, non-empty, max 60 chars

**Relationships**:
- **One-to-Many** with Product

---

## Client-Only Entities (Cart State)

### CartItemDTO

Represents a single product in the shopping cart with quantity and calculated line total.

```typescript
// src/cases/cart/dtos/cart-item.dto.ts

export interface CartItemDTO {
  /**
   * Full product object
   * Contains all product details (name, price, etc.) for display
   * Allows cart to work even if product is deleted from backend
   */
  product: ProductDTO;
  
  /**
   * Quantity of this product in cart
   * Required, positive integer, min: 1
   * Example: 2 (user wants 2 units)
   */
  quantity: number;
  
  /**
   * Calculated line total (quantity × product.price)
   * Calculated field, not stored separately
   * Example: If quantity=2 and price=89.90, lineTotal=179.80
   */
  lineTotal: number;
}
```

**Validation Rules**:
- `product`: Required, must be valid ProductDTO
- `quantity`: Required, positive integer, min 1, max 999
- `lineTotal`: Calculated as `quantity * product.price`, always positive

**Calculation Logic**:
```typescript
function calculateLineTotal(item: Pick<CartItemDTO, 'quantity' | 'product'>): number {
  return item.quantity * item.product.price;
}
```

---

### CartStateDTO

Aggregates all cart items with calculated totals. Root state for cart Context.

```typescript
// src/cases/cart/dtos/cart-state.dto.ts

export interface CartStateDTO {
  /**
   * Array of cart items
   * Can be empty (empty cart)
   * Unique by product.id (no duplicate products)
   */
  items: CartItemDTO[];
  
  /**
   * Total price of all items in cart
   * Calculated as sum of all lineTotals
   * Example: 269.70 for 3 items
   */
  subtotal: number;
  
  /**
   * Total number of items in cart (sum of quantities)
   * Used for cart badge count in header
   * Example: 5 (if 3 items with quantities 2, 1, 2)
   */
  itemCount: number;
}
```

**Validation Rules**:
- `items`: Array, can be empty
- `subtotal`: Calculated as sum of all `item.lineTotal`, always >= 0
- `itemCount`: Calculated as sum of all `item.quantity`, always >= 0

**Calculation Logic**:
```typescript
function calculateSubtotal(items: CartItemDTO[]): number {
  return items.reduce((sum, item) => sum + item.lineTotal, 0);
}

function calculateItemCount(items: CartItemDTO[]): number {
  return items.reduce((sum, item) => sum + item.quantity, 0);
}
```

---

## localStorage Persistence Schema

Cart state is persisted to `localStorage` under key `ecommerce-cart`:

```typescript
// Structure stored in localStorage
interface CartStorage {
  /**
   * Schema version for future migrations
   * Current: "1.0"
   */
  version: string;
  
  /**
   * Array of cart items (serialized CartItemDTO[])
   */
  items: CartItemDTO[];
  
  /**
   * Timestamp of last update (ISO8601 string)
   * Example: "2025-11-22T18:30:00.000Z"
   */
  lastUpdated: string;
}
```

**Storage Example**:
```json
{
  "version": "1.0",
  "items": [
    {
      "product": {
        "id": "prod-123",
        "name": "Hydrating Serum",
        "price": 89.90,
        "active": true,
        "category": { "id": "cat-1", "name": "Skincare" },
        "brand": { "id": "brand-1", "name": "Glow Up" }
      },
      "quantity": 2,
      "lineTotal": 179.80
    }
  ],
  "lastUpdated": "2025-11-22T18:30:00.000Z"
}
```

**Size Considerations**:
- Average product JSON: ~200 bytes
- 20 items in cart: ~4KB
- Well within 5MB localStorage limit

---

## Entity Relationships Diagram

```
┌─────────────────┐
│   CategoryDTO   │
│  - id: string   │
│  - name: string │
└────────┬────────┘
         │ 1
         │
         │ N
┌────────▼─────────────────────┐
│       ProductDTO             │
│  - id: string                │
│  - name: string              │
│  - description?: string      │
│  - price: number             │
│  - active: boolean           │
│  - category: CategoryDTO     │◄─────┐
│  - brand?: BrandDTO          │      │
└────────┬─────────────────────┘      │
         │                             │
         │                             │
         │                        ┌────┴────────┐
         │                        │  BrandDTO   │
         │                        │ - id: string│
         │                        │ - name: str │
         │                        └─────────────┘
         │
         │ (embedded)
         │
┌────────▼─────────────────────┐
│      CartItemDTO             │
│  - product: ProductDTO       │
│  - quantity: number          │
│  - lineTotal: number (calc)  │
└────────┬─────────────────────┘
         │ N
         │
         │ 1
┌────────▼─────────────────────┐
│     CartStateDTO             │
│  - items: CartItemDTO[]      │
│  - subtotal: number (calc)   │
│  - itemCount: number (calc)  │
└──────────────────────────────┘
         │
         │ (persisted to)
         │
┌────────▼─────────────────────┐
│   localStorage               │
│   key: "ecommerce-cart"      │
│   value: CartStorage JSON    │
└──────────────────────────────┘
```

---

## Type Exports and Barrel Files

**Catalog DTOs** (barrel export):
```typescript
// src/cases/catalog/dtos/index.ts
export * from './product.dto';
export * from './category.dto';
export * from './brand.dto';
```

**Cart DTOs** (barrel export):
```typescript
// src/cases/cart/dtos/index.ts
export * from './cart-item.dto';
export * from './cart-state.dto';
```

**Usage in Components**:
```typescript
import { ProductDTO, CategoryDTO } from '@/cases/catalog/dtos';
import { CartItemDTO, CartStateDTO } from '@/cases/cart/dtos';
```

---

## Zod Validation Schemas (Optional)

While TypeScript provides compile-time types, Zod schemas validate runtime data (from API or localStorage):

```typescript
// src/cases/catalog/dtos/product.dto.ts (extended)
import { z } from 'zod';

export const ProductDTOSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1).max(255),
  description: z.string().optional(),
  price: z.number().positive().multipleOf(0.01),
  active: z.boolean(),
  category: z.lazy(() => CategoryDTOSchema),
  brand: z.lazy(() => BrandDTOSchema).optional(),
});

export type ProductDTO = z.infer<typeof ProductDTOSchema>;
```

Use in service layer to validate API responses before returning to hooks.

---

## Summary

- **3 Backend DTOs**: ProductDTO, CategoryDTO, BrandDTO (read-only from API)
- **2 Client DTOs**: CartItemDTO, CartStateDTO (cart state management)
- **1 Storage Schema**: CartStorage (localStorage persistence)
- **All DTOs** follow constitution's DTOs-first principle
- **Exact match** with backend entities (no transformation needed)
- **Calculated fields** clearly documented (lineTotal, subtotal, itemCount)
- **Ready for** service layer, hooks, and component implementation
